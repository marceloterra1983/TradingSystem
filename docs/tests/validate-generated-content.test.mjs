import test from 'node:test';
import assert from 'node:assert';
import {readFile} from 'node:fs/promises';
import {join} from 'node:path';
import {fileURLToPath} from 'node:url';

const DOCS_ROOT = fileURLToPath(new URL('..', import.meta.url));

async function readIfExists(relativePath) {
  try {
    const buffer = await readFile(join(DOCS_ROOT, relativePath), 'utf8');
    return buffer.toString();
  } catch (error) {
    return null;
  }
}

function extractBetween(content, marker) {
  const escape = (value) => value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  const begin = `<!-- BEGIN AUTO-GENERATED: ${marker} -->`;
  const end = `<!-- END AUTO-GENERATED: ${marker} -->`;
  const pattern = new RegExp(`${escape(begin)}([\\s\\S]*?)${escape(end)}`);
  const match = content.match(pattern);
  return match ? match[1].trim() : null;
}

test('ports-services/overview.mdx has valid generated content', async (t) => {
  const content = await readIfExists('content/tools/ports-services/overview.mdx');
  if (!content) {
    t.skip('ports overview not found');
    return;
  }

  assert.match(content, /<!-- AUTO-GENERATED SECTIONS by docs:auto - DO NOT EDIT MANUALLY -->/);
  assert.match(content, /<!-- BEGIN AUTO-GENERATED: Application Services -->/);
  assert.match(content, /<!-- END AUTO-GENERATED: Application Services -->/);
  assert.match(content, /<!-- BEGIN AUTO-GENERATED: Data & Monitoring Services -->/);
  assert.match(content, /<!-- END AUTO-GENERATED: Data & Monitoring Services -->/);
  assert.match(content, /\| Service \| Container \| Port \| URL \| Description \|/);

  const application = extractBetween(content, 'Application Services');
  assert(application, 'Application Services block missing');
  const applicationRows = application.split('\n').filter((line) => line.startsWith('|') && !line.includes('Service'));
  assert(applicationRows.length >= 5, 'Expected at least five application services');

  applicationRows.forEach((row) => {
    assert(row.trim().endsWith('|'), 'Application service row must end with pipe');
  });

  const dataMonitoring = extractBetween(content, 'Data & Monitoring Services');
  assert(dataMonitoring, 'Data & Monitoring Services block missing');
  assert.match(dataMonitoring, /\| Service \| Container \| Port \| URL \| Description \|/);
  const dataMonitoringRows = dataMonitoring
    .split('\n')
    .filter((line) => line.startsWith('|') && !line.includes('Service | Container | Port | URL | Description'));
  assert(dataMonitoringRows.length >= 1, 'Expected at least one data/monitoring service row');

  assert.ok(
    !/\| Service \| Container \| Port\/URL \| Description \|/.test(content),
    'Deprecated 4-column header (Port/URL) should not be present',
  );
  assert.ok(
    !/\| Serviço \| Container \| Porta\/URL \| Descrição \|/.test(content),
    'Deprecated Portuguese 4-column header should not be present',
  );
});

test('frontend/design-system/tokens.mdx has valid generated content', async (t) => {
  const content = await readIfExists('content/frontend/design-system/tokens.mdx');
  if (!content) {
    t.skip('design tokens doc not found');
    return;
  }

  assert.match(content, /<!-- AUTO-GENERATED by docs:auto - DO NOT EDIT MANUALLY -->/);
  assert.match(content, /<!-- BEGIN AUTO-GENERATED: Token Catalogue -->/);
  assert.match(content, /<!-- END AUTO-GENERATED: Token Catalogue -->/);
  assert.match(content, /\| Category \| Name \| Value \| Description \|/);

  const tokens = extractBetween(content, 'Token Catalogue');
  assert(tokens, 'Token Catalogue block missing');
  const tokenRows = tokens
    .split('\n')
    .filter((line) => line.startsWith('|') && !line.includes('Category') && !line.includes('----------'));
  if (tokenRows.length < 2) {
    t.skip('token table placeholder detected');
    return;
  }

  tokenRows.forEach((row) => {
    const cells = row.split('|').map((cell) => cell.trim()).filter(Boolean);
    const value = cells[2];
    assert(value.startsWith('#'), 'Token value should be hex color with # prefix');
    assert.strictEqual(cells[0], 'color');
  });
});

test('mcp/registry.mdx notes automation blocker', async (t) => {
  const content = await readIfExists('content/mcp/registry.mdx');
  if (!content) {
    t.skip('MCP registry doc not found');
    return;
  }

  assert.match(content, /⚠️ \*\*TODO\*\* - Automation blocked/);
  assert.match(content, /external to the repository/, 'Expected explanation of external config access');
  assert.match(content, /Resolve external config access/, 'Expected future enhancement bullet');
});

test('generated files have recent timestamps', async (t) => {
  const portsContent = await readIfExists('content/tools/ports-services/overview.mdx');
  const tokensContent = await readIfExists('content/frontend/design-system/tokens.mdx');
  if (!portsContent || !tokensContent) {
    t.skip('generated docs not found');
    return;
  }

  const timestampPattern = /<!-- Last generated: ([^>]+) -->/;
  const portsMatch = portsContent.match(timestampPattern);
  const tokensMatch = tokensContent.match(timestampPattern);
  if (!portsMatch || !tokensMatch) {
    t.skip('timestamp marker missing');
    return;
  }
  if (portsMatch[1].includes('PLACEHOLDER') || tokensMatch[1].includes('PLACEHOLDER')) {
    t.skip('timestamp placeholder detected');
    return;
  }

  const now = Date.now();
  const portsTimestamp = Date.parse(portsMatch[1]);
  const tokensTimestamp = Date.parse(tokensMatch[1]);

  assert(!Number.isNaN(portsTimestamp), 'Ports timestamp should be ISO 8601');
  assert(!Number.isNaN(tokensTimestamp), 'Tokens timestamp should be ISO 8601');
  const day = 24 * 60 * 60 * 1000;
  assert(now - portsTimestamp < day, 'Ports doc timestamp should be within 24 hours');
  assert(now - tokensTimestamp < day, 'Tokens doc timestamp should be within 24 hours');
});

test('generated sections remain automation-owned', async (t) => {
  const portsContent = await readIfExists('content/tools/ports-services/overview.mdx');
  const tokensContent = await readIfExists('content/frontend/design-system/tokens.mdx');
  if (!portsContent || !tokensContent) {
    t.skip('generated docs not found');
    return;
  }

  const blocks = [
    extractBetween(portsContent, 'Application Services'),
    extractBetween(portsContent, 'Data & Monitoring Services'),
    extractBetween(tokensContent, 'Token Catalogue'),
  ].filter(Boolean);

  blocks.forEach((block) => {
    assert(!/MANUAL EDIT/i.test(block), 'Generated block contains manual edit marker');
    assert(!/TODO/i.test(block), 'Generated block should not carry TODOs');
  });
});

test('generated files preserve frontmatter', async (t) => {
  const files = [
    await readIfExists('content/tools/ports-services/overview.mdx'),
    await readIfExists('content/frontend/design-system/tokens.mdx'),
  ];
  if (files.some((file) => !file)) {
    t.skip('generated docs not found');
    return;
  }

  files.forEach((content) => {
    const match = content.match(/^---[\s\S]*?---/);
    assert(match, 'Frontmatter not found');
    assert.match(match[0], /title:/);
    assert.match(match[0], /description:/);
    assert.match(match[0], /tags:/);
    assert.match(match[0], /owner:/);
    assert.match(match[0], /lastReviewed:/);
  });
});
