@startuml WebScraperSequence
title WebScraper End-to-End Flow

actor User
participant "WebScraper App\n(React)" as App
participant "WebScraper API\n(Express)" as API
participant "Firecrawl Proxy\n(Express)" as Proxy
participant "Firecrawl Service\n(Node.js)" as Firecrawl
database "TimescaleDB" as DB

== Scenario 1 路 New Scrape ==
User -> App : Fill form & submit
App -> App : Validate input\n(frontend guards)
App -> Proxy : POST /api/v1/scrape (options)
Proxy -> Firecrawl : Forward scrape request
Firecrawl --> Proxy : Result payload / error
Proxy --> App : { success, data?, error? }
alt success
  App -> API : POST /api/v1/jobs\n(type=scrape, url, options, results)
  API -> DB : INSERT scrape_jobs
  API --> App : { success: true, data: job }
  App --> User : Render markdown / JSON preview
else failure
  App --> User : Render warning toast
end

== Scenario 2 路 Apply Template ==
User -> App : "Apply Template"
App -> API : GET /api/v1/templates/:id
API -> DB : SELECT template
DB --> API : Template row
API --> App : Template JSON
App -> App : Prefill form\n(options, urlPattern)

== Scenario 3 路 Rerun Job ==
User -> App : Trigger rerun
App -> API : POST /api/v1/jobs/:id/rerun
API -> DB : SELECT job
alt job found
  API -> Proxy : POST /api/v1/scrape|crawl (stored options)
  Proxy -> Firecrawl : Execute request
  Firecrawl --> Proxy : Result or job id
  Proxy --> API : Response
  API -> DB : INSERT new scrape_jobs row
  API --> App : { success: true, data: newJob }
else missing job
  API --> App : { success: false, error: "Job not found" }
end

== Scenario 4 路 View Statistics ==
User -> App : Open dashboard
App -> API : GET /api/v1/statistics?dateFrom&dateTo
API -> DB : Aggregate queries (groupBy + raw SQL)
DB --> API : Aggregated result set
API --> App : Totals, charts data
App --> User : Render insights & charts

@enduml
