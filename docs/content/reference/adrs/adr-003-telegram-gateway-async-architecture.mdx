---
title: "ADR-003: Telegram Gateway Async Architecture"
slug: /reference/adrs/adr-003-telegram-gateway-async-architecture
sidebar_position: 3
tags: [adr, architecture, telegram, async, rabbitmq, mtproto]
domain: backend
type: architecture-decision
summary: "Redesenhar arquitetura do Telegram Gateway para isolar MTProto Worker e implementar comunica√ß√£o ass√≠ncrona via RabbitMQ"
status: proposed
last_review: "2025-11-14"
---

# ADR-003: Telegram Gateway Async Architecture

**Status**: üéØ Proposed

**Deciders**: Engineering Team, Product Owner

**Date**: 2025-11-14

**Technical Story**: [NOVA-ARQUITETURA-MTPROTO-ISOLADO.md](https://github.com/marceloterra1983/TradingSystem/blob/main/docs/NOVA-ARQUITETURA-MTPROTO-ISOLADO.md)

---

## Context and Problem Statement

A arquitetura atual do Telegram Gateway apresenta **problemas recorrentes** que afetam a experi√™ncia do usu√°rio:

1. **Gateway API retorna 502 Bad Gateway** quando MTProto est√° offline ou desconectado
2. **Sess√£o do Telegram n√£o persiste** entre restarts do container MTProto
3. **Acoplamento forte** entre Gateway API e MTProto (depend√™ncia s√≠ncrona)
4. **Sem cache inteligente** - cada request baixa mensagens novamente
5. **Sem fallback** - falha tempor√°ria do MTProto = erro imediato ao usu√°rio
6. **Autentica√ß√£o interativa n√£o funciona** dentro do container Docker

### Sintomas Observados

```javascript
// Console do browser
POST http://localhost:9082/api/telegram-gateway/sync-messages 502 (Bad Gateway)

// Backend logs
{
  "status": 503,
  "error": "Telegram client n√£o est√° conectado. Execute a autentica√ß√£o primeiro."
}

// Frontend logs
[TelegramGateway] Using runtime configuration API
Gateway: unhealthy
Telegram: Desconectado - Verificar autentica√ß√£o
Sistema n√£o est√° completamente operacional
```

### Pergunta do Usu√°rio

> "continua com os mesmos problemas. e se tentarmos uma arquitetura que o MTProto fica isolado fornecendo o acesso ao telegram? como rever esta arquitetura de funcionamento que fica repetindo o problema"

---

## Decision Drivers

### Requisitos T√©cnicos

* **R1**: Gateway API deve **SEMPRE** responder (mesmo com MTProto offline)
* **R2**: Sess√£o do Telegram deve **persistir** entre container restarts
* **R3**: Frontend deve receber **resposta imediata** (n√£o aguardar sync completo)
* **R4**: Cache de mensagens deve evitar requests desnecess√°rios
* **R5**: Sistema deve ser **resiliente** a falhas tempor√°rias do MTProto
* **R6**: Arquitetura deve seguir **Single Responsibility Principle (SRP)**

### Requisitos de Neg√≥cio

* **B1**: Usu√°rio n√£o deve ver erro 502 ao clicar "Sync Messages"
* **B2**: Mensagens cacheadas devem aparecer instantaneamente (< 100ms)
* **B3**: Sistema deve funcionar 24/7 sem interven√ß√£o manual
* **B4**: Falhas do MTProto n√£o devem derrubar o dashboard inteiro

---

## Considered Options

### Option 1: Manter Arquitetura Atual (S√≠ncrona)

**Descri√ß√£o**: Continuar com Gateway API ‚Üí MTProto s√≠ncrono

**Pr√≥s**:
* ‚úÖ Menos complexidade (sem message broker)
* ‚úÖ Resposta em tempo real (quando funciona)
* ‚úÖ N√£o requer refatora√ß√£o

**Contras**:
* ‚ùå Gateway API depende 100% do MTProto
* ‚ùå 502 Bad Gateway quando MTProto offline
* ‚ùå Sem cache = requests lentos
* ‚ùå Sess√£o n√£o persiste
* ‚ùå **Problemas recorrentes n√£o resolvidos**

**Decis√£o**: ‚ùå **REJEITADA** - N√£o resolve os problemas fundamentais

---

### Option 2: Nova Arquitetura Ass√≠ncrona (Recomendada)

**Descri√ß√£o**: Isolar MTProto Worker + RabbitMQ + Redis Cache

```
Browser ‚Üí Gateway API ‚Üí RabbitMQ ‚Üí MTProto Worker ‚Üí Telegram
          ‚Üì (202 Accepted)      ‚Üë
      Redis Cache HIT/MISS    (async)
```

**Pr√≥s**:
* ‚úÖ Gateway API **SEMPRE** dispon√≠vel (R1)
* ‚úÖ Sess√£o persiste em volume Docker (R2)
* ‚úÖ Response imediato: 202 Accepted (R3)
* ‚úÖ Cache Redis evita requests desnecess√°rios (R4)
* ‚úÖ Resiliente a falhas MTProto (R5)
* ‚úÖ Separa√ß√£o de responsabilidades (R6)
* ‚úÖ RabbitMQ absorve picos de carga
* ‚úÖ Retry autom√°tico via message broker
* ‚úÖ Escal√°vel (pode adicionar m√∫ltiplos workers)

**Contras**:
* ‚ö†Ô∏è Maior complexidade (RabbitMQ + polling)
* ‚ö†Ô∏è Frontend precisa implementar polling
* ‚ö†Ô∏è Lat√™ncia adicional para cache miss (async)
* ‚ö†Ô∏è Refatora√ß√£o de c√≥digo existente

**Decis√£o**: ‚úÖ **ACEITA** - Resolve todos os problemas fundamentais

---

### Option 3: WebSocket Real-time (Alternativa Futura)

**Descri√ß√£o**: Usar WebSocket para notifica√ß√£o real-time (em vez de polling)

**Pr√≥s**:
* ‚úÖ Notifica√ß√£o instant√¢nea ao frontend
* ‚úÖ Sem overhead de polling HTTP

**Contras**:
* ‚ö†Ô∏è Maior complexidade de implementa√ß√£o
* ‚ö†Ô∏è Requer gerenciamento de conex√µes WebSocket
* ‚ö†Ô∏è Pode ser implementada **AP√ìS** Option 2

**Decis√£o**: üîÑ **FUTURE** - Implementar ap√≥s validar Option 2

---

## Decision Outcome

**Chosen option**: **Option 2 - Nova Arquitetura Ass√≠ncrona**

### Justificativa

A arquitetura ass√≠ncrona resolve **TODOS os problemas identificados**:

1. ‚úÖ **R1 (Gateway sempre dispon√≠vel)**: Gateway API n√£o depende do MTProto
2. ‚úÖ **R2 (Sess√£o persistente)**: Volume Docker `/data/.session`
3. ‚úÖ **R3 (Resposta imediata)**: 202 Accepted + Job ID
4. ‚úÖ **R4 (Cache inteligente)**: Redis cache com TTL 5 min
5. ‚úÖ **R5 (Resili√™ncia)**: RabbitMQ queue + retry logic
6. ‚úÖ **R6 (SRP)**: Gateway API (HTTP) ‚â† MTProto Worker (Telegram)

### Positive Consequences

* ‚úÖ **UX Melhorada**: Usu√°rio nunca v√™ 502 Bad Gateway
* ‚úÖ **Performance**: Cache Redis retorna dados em < 100ms
* ‚úÖ **Reliability**: Sistema funciona mesmo com MTProto offline
* ‚úÖ **Scalability**: Pode adicionar m√∫ltiplos MTProto Workers
* ‚úÖ **Maintainability**: C√≥digo mais limpo com responsabilidades separadas
* ‚úÖ **Observability**: M√©tricas RabbitMQ (queue depth, processing time)

### Negative Consequences

* ‚ö†Ô∏è **Complexidade**: Adiciona RabbitMQ como depend√™ncia
* ‚ö†Ô∏è **Lat√™ncia**: Cache miss = async processing (n√£o instant√¢neo)
* ‚ö†Ô∏è **Refactoring**: Requer mudan√ßas em frontend + backend
* ‚ö†Ô∏è **Learning Curve**: Time precisa entender RabbitMQ

---

## Implementation Plan

### Fase 1: Prepara√ß√£o (1-2 dias)

**Tasks**:
* [ ] Criar volume Docker para sess√£o Telegram
* [ ] Script de autentica√ß√£o interativa one-time
* [ ] Configurar RabbitMQ queues e exchanges
* [ ] Documentar processo de autentica√ß√£o inicial

**Deliverables**:
* Volume `telegram-mtproto-session` criado
* Script `scripts/telegram/authenticate-interactive.sh`
* Queues `telegram.sync.requests` e `telegram.sync.responses` configuradas

---

### Fase 2: MTProto Worker Isolado (2-3 dias)

**Tasks**:
* [ ] Criar `apps/telegram-gateway/src/worker.js`
* [ ] Implementar consumidor RabbitMQ
* [ ] Adicionar health check via RabbitMQ connection
* [ ] Implementar graceful shutdown handler
* [ ] Testar sess√£o persistence entre restarts

**Deliverables**:
* MTProto Worker rodando 24/7
* Sess√£o persiste em `/data/.session`
* Health check funcional
* Dockerfile atualizado (worker mode)

**Code Example**:

```javascript
// apps/telegram-gateway/src/worker.js
const amqp = require('amqplib');
const { TelegramClient } = require('telegram');

let telegramClient;
let rabbitChannel;

async function processMessage(msg) {
  const request = JSON.parse(msg.content.toString());
  const { jobId, action, params } = request;

  try {
    let result;

    switch (action) {
      case 'sync-messages':
        result = await syncMessages(params);
        break;
      case 'get-channels':
        result = await getChannels(params);
        break;
    }

    // Publish result
    await rabbitChannel.sendToQueue('telegram.sync.responses',
      Buffer.from(JSON.stringify({
        jobId,
        status: 'completed',
        result,
        timestamp: new Date().toISOString(),
      }))
    );

    rabbitChannel.ack(msg);
  } catch (error) {
    // Publish error + retry logic
    const retryCount = msg.properties.headers['x-retry-count'] || 0;
    if (retryCount < 3) {
      rabbitChannel.nack(msg, false, true); // Requeue
    } else {
      rabbitChannel.ack(msg); // Discard after 3 retries
    }
  }
}

async function main() {
  await connectTelegram();
  await connectRabbitMQ();
  rabbitChannel.consume('telegram.sync.requests', processMessage);
}

main();
```

---

### Fase 3: Gateway API Refactoring (2-3 dias)

**Tasks**:
* [ ] Implementar cache-first logic (Redis)
* [ ] Criar endpoint `/api/telegram-gateway/jobs/:id`
* [ ] Refatorar `/sync-messages` para async (202 Accepted)
* [ ] Adicionar RabbitMQ producer logic
* [ ] Consumer de `telegram.sync.responses`

**Deliverables**:
* Gateway API retorna 202 Accepted
* Redis cache funcionando (5 min TTL)
* Job polling endpoint funcional
* RabbitMQ producer implementado

**Code Example**:

```javascript
// backend/api/telegram-gateway/src/routes/telegramGateway.js

// Async sync-messages endpoint
telegramGatewayRouter.post('/sync-messages', async (req, res) => {
  const { channelId, limit } = req.body;
  const cacheKey = `telegram:messages:${channelId}:${limit}`;

  // 1. Try cache first
  const cached = await redis.get(cacheKey);
  if (cached) {
    return res.json({
      success: true,
      messages: JSON.parse(cached),
      source: 'cache',
    });
  }

  // 2. Enqueue job
  const jobId = `sync-${Date.now()}-${randomId()}`;

  await rabbitChannel.sendToQueue('telegram.sync.requests',
    Buffer.from(JSON.stringify({
      jobId,
      action: 'sync-messages',
      params: { channelId, limit },
    }))
  );

  // 3. Store job metadata
  await redis.setex(`job:${jobId}`, 600, JSON.stringify({
    status: 'queued',
    createdAt: new Date().toISOString(),
  }));

  // 4. Return job ID for polling
  res.status(202).json({
    success: true,
    jobId,
    status: 'queued',
    pollUrl: `/api/telegram-gateway/jobs/${jobId}`,
  });
});

// Job polling endpoint
telegramGatewayRouter.get('/jobs/:jobId', async (req, res) => {
  const { jobId } = req.params;
  const jobData = await redis.get(`job:${jobId}`);

  if (!jobData) {
    return res.status(404).json({ error: 'Job not found' });
  }

  res.json(JSON.parse(jobData));
});
```

---

### Fase 4: Frontend Updates (1 dia)

**Tasks**:
* [ ] Implementar polling logic no `useTelegramGateway.ts`
* [ ] Adicionar loading states (queued, processing, completed)
* [ ] Tratamento de erros async
* [ ] UI feedback para cache hit/miss

**Deliverables**:
* Polling implementado com intervalo de 2s
* Loading states no dashboard
* Error handling gracioso

**Code Example**:

```typescript
// frontend/dashboard/src/hooks/useTelegramGateway.ts

export function useSyncMessages() {
  const [jobId, setJobId] = useState<string | null>(null);

  // Mutation para iniciar sync
  const syncMutation = useMutation({
    mutationFn: async (params: SyncParams) => {
      const response = await fetch('/api/telegram-gateway/sync-messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params),
      });

      const data = await response.json();

      if (data.source === 'cache') {
        // Cache hit - retorna dados imediatamente
        return data;
      }

      // Cache miss - retorna jobId para polling
      setJobId(data.jobId);
      return data;
    },
  });

  // Polling query (apenas se jobId exists)
  const pollingQuery = useQuery({
    queryKey: ['telegram-job', jobId],
    queryFn: async () => {
      const response = await fetch(`/api/telegram-gateway/jobs/${jobId}`);
      return response.json();
    },
    enabled: !!jobId,
    refetchInterval: (data) => {
      // Stop polling quando status = completed ou failed
      if (data?.status === 'completed' || data?.status === 'failed') {
        setJobId(null);
        return false;
      }
      return 2000; // Poll every 2s
    },
  });

  return {
    sync: syncMutation.mutate,
    isLoading: syncMutation.isPending || pollingQuery.isFetching,
    status: pollingQuery.data?.status || 'idle',
    result: pollingQuery.data?.result,
    error: syncMutation.error || pollingQuery.error,
  };
}
```

---

### Fase 5: Valida√ß√£o E2E (1 dia)

**Tasks**:
* [ ] Testar full flow: Frontend ‚Üí Gateway ‚Üí RabbitMQ ‚Üí Worker ‚Üí Telegram
* [ ] Validar cache hit/miss scenarios
* [ ] Testar MTProto Worker offline/online
* [ ] Verificar sess√£o persistence
* [ ] Load testing (100 concurrent requests)

**Deliverables**:
* Test suite E2E passing
* Load test results (< 200ms p99 latency)
* Documenta√ß√£o de testes

---

## Compliance

### Architecture Principles

* ‚úÖ **Single Responsibility**: Gateway API (HTTP) ‚â† MTProto Worker (Telegram)
* ‚úÖ **Dependency Inversion**: Gateway depends on abstractions (RabbitMQ), not MTProto
* ‚úÖ **Loose Coupling**: Components comunicam via message broker
* ‚úÖ **High Cohesion**: Cada servi√ßo tem responsabilidade bem definida

### Security

* ‚úÖ **Session Isolation**: Sess√£o Telegram em volume protegido
* ‚úÖ **Authentication**: X-Gateway-Token no Gateway API
* ‚úÖ **No Credentials in Logs**: Nunca logar session data
* ‚úÖ **Encrypted Volume**: Volume Docker com encryption at rest

### Performance

* üéØ **Target**: Cache hit < 100ms, cache miss < 5s
* üéØ **Redis TTL**: 5 minutos (balance freshness vs performance)
* üéØ **RabbitMQ**: Prefetch 10 mensagens (worker throughput)
* üéØ **Polling Interval**: 2s (balance latency vs server load)

---

## Links

### Documentation

* [NOVA-ARQUITETURA-MTPROTO-ISOLADO.md](https://github.com/marceloterra1983/TradingSystem/blob/main/docs/NOVA-ARQUITETURA-MTPROTO-ISOLADO.md) - Proposta completa
* [Diagram PlantUML](https://github.com/marceloterra1983/TradingSystem/blob/main/docs/content/diagrams/telegram-gateway-async-architecture.puml) - Arquitetura visual
* [RUNTIME-CONFIG-API-ARCHITECTURE.md](https://github.com/marceloterra1983/TradingSystem/blob/main/docs/RUNTIME-CONFIG-API-ARCHITECTURE.md) - Runtime Config (j√° implementado)

### External References

* [RabbitMQ Work Queues Tutorial](https://www.rabbitmq.com/tutorials/tutorial-two-javascript.html)
* [GramJS Documentation](https://gram.js.org/)
* [Job Queue Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/JobQueuePattern.html)

---

**Aprova√ß√£o**: ‚è≥ Aguardando valida√ß√£o do Product Owner e Engineering Team

**Pr√≥xima A√ß√£o**: Iniciar Fase 1 (Prepara√ß√£o) ap√≥s aprova√ß√£o formal

**Tempo Estimado Total**: 7-10 dias √∫teis
