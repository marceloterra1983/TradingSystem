import express from 'express';
import { Octokit } from '@octokit/rest';
import pino from 'pino';

const PORT = Number(process.env.PORT ?? 8080);
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_OWNER = process.env.GITHUB_OWNER;
const GITHUB_REPO = process.env.GITHUB_REPO;

const logger = pino({ level: process.env.LOG_LEVEL || 'info' });
const app = express();
app.use(express.json({ limit: '2mb' }));

let octokit = null;
if (GITHUB_TOKEN && GITHUB_OWNER && GITHUB_REPO) {
  octokit = new Octokit({ auth: GITHUB_TOKEN });
  logger.info({ owner: GITHUB_OWNER, repo: GITHUB_REPO }, 'GitHub alert routing enabled');
} else {
  logger.warn('GitHub alert routing disabled - missing GITHUB_TOKEN/GITHUB_OWNER/GITHUB_REPO environment variables');
}

const issueLabels = ['alert'];

const fingerprintFromAlert = (alert = {}) => {
  if (alert.fingerprint) return alert.fingerprint;
  const service = alert.labels?.service || alert.labels?.job || 'unknown-service';
  const alertName = alert.labels?.alertname || 'unknown-alert';
  return `${service}-${alertName}`.toLowerCase();
};

const issueTitle = (alert = {}) => {
  const severity = (alert.labels?.severity || 'unknown').toUpperCase();
  const summary =
    alert.annotations?.summary ||
    alert.annotations?.description ||
    alert.labels?.alertname ||
    'Prometheus alert';
  return `[${severity}] ${summary}`;
};

const issueBody = (alert = {}) => {
  const labels = alert.labels || {};
  const annotations = alert.annotations || {};

  return [
    '### Alert Details',
    `- Status: ${alert.status ?? 'unknown'}`,
    `- Severity: ${labels.severity ?? 'unknown'}`,
    `- Service: ${labels.service ?? labels.job ?? 'n/a'}`,
    `- Fingerprint: ${fingerprintFromAlert(alert)}`,
    `- Description: ${annotations.description ?? 'n/a'}`,
    `- Generator: ${annotations.generatorURL ?? 'n/a'}`,
    '',
    '```json',
    JSON.stringify(alert, null, 2),
    '```',
  ].join('\n');
};

const listExistingIssues = async () => {
  const { data } = await octokit.issues.listForRepo({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    state: 'open',
    labels: issueLabels.join(','),
  });
  return data;
};

const findIssueByFingerprint = async (fingerprint) => {
  const openIssues = await listExistingIssues();
  return openIssues.find((issue) => issue.body?.includes(`Fingerprint: ${fingerprint}`));
};

const ensureLabels = async (severity) => {
  const severityLabel = severity ? `severity:${severity.toLowerCase()}` : 'severity:unknown';

  const ensureLabel = async (name, color, description) => {
    try {
      await octokit.issues.getLabel({ owner: GITHUB_OWNER, repo: GITHUB_REPO, name });
    } catch {
      await octokit.issues.createLabel({ owner: GITHUB_OWNER, repo: GITHUB_REPO, name, color, description });
    }
  };

  await ensureLabel('alert', 'ff0000', 'Alert generated by Prometheus');
  await ensureLabel(severityLabel, 'ffa500', 'Prometheus alert severity');

  return severityLabel;
};

const handleAlert = async (alert) => {
  if (!octokit) {
    return { action: 'skipped', reason: 'github-disabled' };
  }

  const fingerprint = fingerprintFromAlert(alert);
  const severity = alert.labels?.severity || 'unknown';
  const severityLabel = await ensureLabels(severity);

  const existing = await findIssueByFingerprint(fingerprint);

  if (alert.status === 'resolved') {
    if (existing) {
      await octokit.issues.createComment({
        owner: GITHUB_OWNER,
        repo: GITHUB_REPO,
        issue_number: existing.number,
        body: 'âœ… Alert resolved by Prometheus. Closing issue.',
      });

      await octokit.issues.update({
        owner: GITHUB_OWNER,
        repo: GITHUB_REPO,
        issue_number: existing.number,
        state: 'closed',
      });

      return { action: 'closed', issue: existing.number };
    }

    return { action: 'resolved-no-issue', fingerprint };
  }

  if (existing) {
    await octokit.issues.createComment({
      owner: GITHUB_OWNER,
      repo: GITHUB_REPO,
      issue_number: existing.number,
      body: 'ðŸš¨ Alert still firing. Prometheus sent an updated notification.',
    });

    return { action: 'commented', issue: existing.number };
  }

  const created = await octokit.issues.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: issueTitle(alert),
    body: issueBody(alert),
    labels: [issueLabels[0], severityLabel],
  });

  return { action: 'created', issue: created.data.number };
};

app.get('/health', (_req, res) => {
  res.json({ status: 'ok', github: Boolean(octokit) });
});

app.post('/github', async (req, res) => {
  const alerts = Array.isArray(req.body?.alerts) ? req.body.alerts : [];

  if (alerts.length === 0) {
    return res.status(400).json({ error: 'No alerts found in payload' });
  }

  const results = [];

  for (const alert of alerts) {
    try {
      const result = await handleAlert(alert);
      results.push({ fingerprint: fingerprintFromAlert(alert), ...result });
    } catch (error) {
      logger.error({ err: error, alert }, 'Failed to process alert');
      results.push({ fingerprint: fingerprintFromAlert(alert), action: 'error', error: error.message });
    }
  }

  res.status(202).json({ processed: results.length, results });
});

app.listen(PORT, () => {
  logger.info({ port: PORT }, 'Alert router listening');
});

