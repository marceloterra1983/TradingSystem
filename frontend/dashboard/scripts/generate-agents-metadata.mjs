#!/usr/bin/env node
/**
 * Generate Agents Metadata File
 *
 * Extracts metadata from aiAgentsDirectory.ts and creates a lightweight
 * metadata-only file without the heavy fileContent fields.
 *
 * Usage:
 *   node scripts/generate-agents-metadata.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const SRC_FILE = path.join(__dirname, '../src/data/aiAgentsDirectory.ts');
const OUT_FILE = path.join(__dirname, '../src/data/aiAgentsDirectory.metadata.ts');

console.log('üîç Reading source file:', SRC_FILE);

// Read the full data file
const sourceContent = fs.readFileSync(SRC_FILE, 'utf-8');

// Extract the AI_AGENTS_DIRECTORY array using regex (handle multiline)
const arrayMatch = sourceContent.match(/export const AI_AGENTS_DIRECTORY[^=]*=\s*(\[[\s\S]*?\n\];)/);

if (!arrayMatch) {
  throw new Error('Could not find AI_AGENTS_DIRECTORY export in source file');
}

// Parse the array (this is a bit hacky but works for generated code)
// We'll use eval in a safe context since this is generated code we control
const agentsArray = eval(arrayMatch[1]);

console.log(`‚úì Found ${agentsArray.length} agents in source file`);

// Strip fileContent from each agent
const metadataArray = agentsArray.map(agent => {
  const { fileContent: _fileContent, ...metadata } = agent;
  return metadata;
});

// Calculate size savings
const fullSize = JSON.stringify(agentsArray).length;
const metadataSize = JSON.stringify(metadataArray).length;
const savings = ((1 - metadataSize / fullSize) * 100).toFixed(1);

console.log(`üìä Size comparison:`);
console.log(`   Full data: ${(fullSize / 1024).toFixed(1)} KB`);
console.log(`   Metadata only: ${(metadataSize / 1024).toFixed(1)} KB`);
console.log(`   Savings: ${savings}%`);

// Generate the output file content
const outputContent = `/**
 * AI Agents Directory - Metadata Only (GENERATED)
 *
 * This file contains only agent metadata WITHOUT full file content.
 * Full agent content is loaded on-demand via loadAgentContent().
 *
 * Size Impact:
 * - Full data: ~${(fullSize / 1024).toFixed(0)}KB
 * - Metadata only: ~${(metadataSize / 1024).toFixed(0)}KB
 * - Reduction: ${savings}%
 *
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-agents-metadata.mjs
 * Generated at: ${new Date().toISOString()}
 */

export const AGENT_CATALOG_SCHEMA_VERSION = "1.1.0";

export type AgentCategory =
  | "Arquitetura & Plataforma"
  | "Backend & Servi√ßos"
  | "Frontend & UX"
  | "Dados & Analytics"
  | "IA, ML & RAG"
  | "Documenta√ß√£o & Conte√∫do"
  | "Pesquisa & Estrat√©gia"
  | "QA & Observabilidade"
  | "MCP & Automa√ß√£o";

export interface AgentMetadata {
  id: string;
  name: string;
  category: AgentCategory;
  capabilities: string;
  usage: string;
  example: string;
  shortExample?: string;
  outputType: string;
  tags: string[];
  filePath: string;
  // fileContent is NOT included - loaded on-demand
}

export const AGENT_CATEGORY_ORDER: AgentCategory[] = [
  "Arquitetura & Plataforma",
  "Backend & Servi√ßos",
  "Frontend & UX",
  "Dados & Analytics",
  "IA, ML & RAG",
  "Documenta√ß√£o & Conte√∫do",
  "Pesquisa & Estrat√©gia",
  "QA & Observabilidade",
  "MCP & Automa√ß√£o"
];

/**
 * Lazy-loads full agent content on-demand
 * @param agentId - The agent ID to load content for
 * @returns Promise with full agent data including fileContent
 */
export async function loadAgentContent(agentId: string): Promise<{ fileContent: string }> {
  // Dynamic import of full data only when needed
  const module = await import('./aiAgentsDirectory');
  const agent = module.AI_AGENTS_DIRECTORY.find((a: any) => a.id === agentId);

  if (!agent?.fileContent) {
    throw new Error(\`Agent content not found for: \${agentId}\`);
  }

  return { fileContent: agent.fileContent };
}

// Metadata-only agents array (fileContent stripped)
export const AI_AGENTS_METADATA: AgentMetadata[] = ${JSON.stringify(metadataArray, null, 2)};
`;

// Write the output file
fs.writeFileSync(OUT_FILE, outputContent, 'utf-8');

console.log(`‚úÖ Generated metadata file: ${OUT_FILE}`);
console.log(`üì¶ Metadata size: ${(metadataSize / 1024).toFixed(1)} KB`);
console.log(`üéØ Bundle size reduction: ~${savings}%`);
