import React from 'react';
import { RefreshCcw } from 'lucide-react';
import { Button } from '../ui/button';
import { Badge } from '../ui/badge';
import DocumentsFilesTable from './DocumentsFilesTable';

export interface LlamaIndexServiceStatus {
  ok: boolean;
  status: number;
  message: string;
  collection?: string;
}

export interface LlamaIndexCollectionInfo {
  name: string;
  count: number | null;
  aliasOf?: string | null;
  embeddingModel?: string | null;
  exists?: boolean;
}

export interface LlamaIndexStatusResponse {
  timestamp: string;
  requestedCollection?: string;
  services: {
    query: LlamaIndexServiceStatus;
    ingestion: LlamaIndexServiceStatus;
  };
  qdrant: {
    collection: string;
    activeCollection?: string | null;
    ok: boolean;
    status: number;
    count: number | null;
    sample: string[];
  };
  collections?: LlamaIndexCollectionInfo[];
  gpuPolicy?: { [key: string]: unknown };
  documentation?: {
    docsDirectory?: string;
    totalDocuments?: number;
    indexedDocuments?: number;
    missingDocuments?: number;
    missingSample?: string[];
    indexedSample?: string[];
    error?: string;
    indexedScanTruncated?: boolean;
    collection?: string;
    indexedUniqueDocuments?: number;
    indexedUniqueSample?: string[];
    allFilesList?: Array<{ path: string; size: number }>;
    orphanChunks?: number;
    orphanSample?: string[];
  };
}

export interface LlamaIndexIngestionResult {
  success?: boolean;
  message?: string;
  documents_processed?: number;
  documents_loaded?: number;
  chunks_generated?: number;
  files_considered?: number;
  files_ingested?: number;
  files_skipped?: number;
  skipped_by_extension?: number;
  skipped_by_size?: number;
  skipped_files_size?: string[];
  skipped_hidden?: number;
  collection?: string;
  embedding_model?: string;
  chunk_size?: number;
  chunk_overlap?: number;
  largest_files?: string[];
  errors?: unknown;
  gpu?: Record<string, unknown>;
}

export interface CollectionDocumentStats {
  total: number | null;
  indexed: number | null;
  missing: number | null;
  orphans: number | null;
  chunks: number | null; // Total chunks in Qdrant (different from unique documents indexed)
}

export interface CollectionLogState {
  lines: string[];
  status: 'idle' | 'running' | 'success' | 'error';
  visible: boolean;
  lastUpdated: number;
}

interface LlamaIndexIngestionStatusCardProps {
  data: LlamaIndexStatusResponse | null;
  loading: boolean;
  error: string | null;
  ingesting: boolean;
  ingestionMessage: string | null;
  lastIngestion?: LlamaIndexIngestionResult | null;
  onRefresh: () => void;
  onRunIngest: (collection: string) => void | Promise<void>;
  onCleanOrphans: (collection: string) => void | Promise<void>;
  cleaningOrphans: boolean;
  collectionOptions: LlamaIndexCollectionInfo[];
  selectedCollection?: string;
  onCollectionChange: (value: string) => void;
  collectionDocStats: Record<string, CollectionDocumentStats>;
  resetCollections: Record<string, boolean>;
  collectionLogs: Record<string, CollectionLogState>;
  onToggleLog: (collection: string) => void;
  deletingCollections: Record<string, boolean>;
  onDeleteCollection: (collection: string) => void;
}

export function LlamaIndexIngestionStatusCard({
  data,
  loading,
  error,
  ingesting,
  ingestionMessage,
  lastIngestion,
  onRefresh,
  onRunIngest,
  onCleanOrphans,
  cleaningOrphans,
  collectionOptions,
  selectedCollection,
  onCollectionChange,
  collectionDocStats,
  resetCollections,
  collectionLogs,
  onToggleLog,
  deletingCollections,
  onDeleteCollection,
}: LlamaIndexIngestionStatusCardProps): JSX.Element {
  const HIDDEN_COLLECTIONS = React.useMemo(() => new Set(['repository']), []);
  const visibleCollections = React.useMemo(
    () =>
      collectionOptions.filter((item) => !HIDDEN_COLLECTIONS.has(item.name.toLowerCase())),
    [collectionOptions, HIDDEN_COLLECTIONS]
  );

  const effectiveCollectionValue = (() => {
    if (selectedCollection && collectionOptions.some((item) => item.name === selectedCollection)) {
      return selectedCollection;
    }
    return visibleCollections[0]?.name ?? collectionOptions[0]?.name ?? '';
  })();

  const selectedCollectionStats = collectionOptions.find((item) => item.name === effectiveCollectionValue);

  const docStats =
    data?.documentation &&
    data.documentation.collection &&
    effectiveCollectionValue &&
    data.documentation.collection.toLowerCase() === effectiveCollectionValue.toLowerCase()
      ? data.documentation
      : data?.documentation?.collection && !effectiveCollectionValue
        ? data.documentation
        : null;

  const statsKey = effectiveCollectionValue ? effectiveCollectionValue.toLowerCase() : '';
  const fallbackDocStats = statsKey ? collectionDocStats[statsKey] : undefined;

  const docTotal =
    docStats?.totalDocuments ??
    (typeof fallbackDocStats?.total === 'number' ? fallbackDocStats.total : null);

  const docIndexedRaw =
    docStats?.indexedUniqueDocuments ??
    docStats?.indexedDocuments ??
    (typeof fallbackDocStats?.indexed === 'number' ? fallbackDocStats.indexed : null);
  const docMissingRaw =
    typeof docStats?.missingDocuments === 'number'
      ? docStats.missingDocuments
      : typeof fallbackDocStats?.missing === 'number'
        ? fallbackDocStats.missing
        : docTotal != null && docIndexedRaw != null
          ? Math.max(docTotal - docIndexedRaw, 0)
          : null;
  const docOrphansRaw =
    docStats?.orphanChunks ??
    (typeof fallbackDocStats?.orphans === 'number' ? fallbackDocStats.orphans : 0);

  const resetAppliedSelected = Boolean(resetCollections[statsKey]);

  const docIndexed = resetAppliedSelected ? 0 : docIndexedRaw ?? 0;
  const docPending = resetAppliedSelected ? (docTotal ?? 0) : docMissingRaw ?? 0;
  const docOrphanChunks = resetAppliedSelected ? 0 : docOrphansRaw ?? 0;

  const docDirectory = docStats?.docsDirectory ?? null;
  const docError = docStats?.error ?? null;
  const docScanTruncated = Boolean(docStats?.indexedScanTruncated);

  const docIndexedSampleRaw = docStats?.indexedSample ?? [];
  // Note: docStats.missingSample and docStats.orphanSample are available but not displayed in current UI
  const docAllFiles = docStats?.allFilesList ?? [];
  const docIndexedSample = resetAppliedSelected ? [] : docIndexedSampleRaw;
  const qdrantActiveCollection = data?.qdrant?.activeCollection ?? null;

  const formatNumber = (value: number | null | undefined): string =>
    typeof value === 'number' ? value.toLocaleString() : '–';

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
  };

  // Create unified file list with status
  const indexedSet = new Set(docIndexedSample);
  const [sortBy, setSortBy] = React.useState<'path' | 'size' | 'status'>('path');
  const [sortDirection, setSortDirection] = React.useState<'asc' | 'desc'>('asc');
  const [logCollapsed, setLogCollapsed] = React.useState<Record<string, boolean>>({});

  const handleSort = (column: 'path' | 'size' | 'status') => {
    if (sortBy === column) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(column);
      setSortDirection('asc');
    }
  };

  const toggleLogCollapse = (collectionName: string) => {
    setLogCollapsed((prev) => ({
      ...prev,
      [collectionName]: !prev[collectionName],
    }));
  };

  const unifiedFileList = React.useMemo(() => {
    const list = docAllFiles.map((file) => ({
      path: file.path,
      size: file.size,
      indexed: indexedSet.has(file.path),
    }));

    return list.sort((a, b) => {
      let comparison = 0;
      
      if (sortBy === 'path') {
        comparison = a.path.localeCompare(b.path);
      } else if (sortBy === 'size') {
        comparison = a.size - b.size;
      } else if (sortBy === 'status') {
        // true (indexed) = 1, false (pendente) = 0
        // ASC: pendente (0) antes de indexed (1) 
        // DESC: indexed (1) antes de pendente (0)
        comparison = (a.indexed ? 1 : 0) - (b.indexed ? 1 : 0);
      }

      return sortDirection === 'asc' ? comparison : -comparison;
    });
  }, [docAllFiles, indexedSet, sortBy, sortDirection]);

  const qdrantHelperParts: string[] = [];
  if (effectiveCollectionValue) {
    qdrantHelperParts.push(`Coleção ${effectiveCollectionValue}`);
  }
  if (qdrantActiveCollection && qdrantActiveCollection !== effectiveCollectionValue) {
    qdrantHelperParts.push(`Query ativo: ${qdrantActiveCollection}`);
  }
  if (selectedCollectionStats?.aliasOf) {
    qdrantHelperParts.push(`Alias de ${selectedCollectionStats.aliasOf}`);
  }
  const qdrantHelperText = qdrantHelperParts.length ? qdrantHelperParts.join(' • ') : null;

  const docIndexedHelperParts: string[] = [];
  if (docTotal != null) {
    docIndexedHelperParts.push(`${formatNumber(docTotal)} arquivos no diretório`);
  }
  if (
    typeof docStats?.indexedDocuments === 'number' &&
    docStats.indexedDocuments !== docIndexed
  ) {
    docIndexedHelperParts.push(`${formatNumber(docStats.indexedDocuments)} documentos contabilizados`);
  }
  const docIndexedHelper = docIndexedHelperParts.length ? docIndexedHelperParts.join(' • ') : null;

  const docPendingHelper = docError
    ? 'Falha ao ler diretório'
    : docPending != null
      ? docPending === 0
        ? 'Coleção completa'
        : docPending === 1
          ? '1 documento pendente'
          : `${formatNumber(docPending)} documentos aguardando ingestão`
      : null;

  const MetricCard = ({
    label,
    value,
    helper,
    monospace = false,
  }: {
    label: string;
    value: string;
    helper?: string | null;
    monospace?: boolean;
  }) => (
    <div className="rounded-md border border-slate-200 dark:border-slate-800 bg-slate-50/60 dark:bg-slate-900/40 p-3">
      <p className="text-[11px] uppercase tracking-wide text-slate-500 dark:text-slate-400">{label}</p>
      <p
        className={`mt-1 text-lg font-semibold text-slate-800 dark:text-slate-100 ${
          monospace ? 'font-mono text-[13px] leading-tight break-all' : ''
        }`}
      >
        {value}
      </p>
      {helper ? <p className="text-xs text-slate-500 dark:text-slate-400">{helper}</p> : null}
    </div>
  );

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm font-semibold text-slate-700 dark:text-slate-200">Ingestion Overview</p>
          <p className="text-xs text-slate-500 dark:text-slate-400">
            Última atualização: {data?.timestamp ? new Date(data.timestamp).toLocaleString() : '–'}
          </p>
        </div>
        <Button size="sm" variant="outline" onClick={onRefresh} disabled={loading || ingesting} className="gap-2">
          <RefreshCcw className={`h-4 w-4 ${loading ? 'animate-spin' : ''}`} />
          Atualizar
        </Button>
      </div>

      {error && (
        <div className="rounded-md border border-red-300 bg-red-50 dark:bg-red-900/20 p-3 text-sm text-red-600 dark:text-red-300">
          {error}
        </div>
      )}

      {ingestionMessage && !error && (
        <div className="rounded-md border border-slate-200 dark:border-slate-700 bg-slate-100 dark:bg-slate-800/60 p-3 text-xs text-slate-600 dark:text-slate-300">
          {ingestionMessage}
        </div>
      )}

      {!error && (
        <div className="space-y-3">
          <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900/60 px-3 py-3 space-y-3">
            <div>
              <p className="text-sm font-medium text-slate-700 dark:text-slate-200">Configuração de ingestão</p>
              <p className="text-xs text-slate-500 dark:text-slate-400">
                Cada coleção possui um modelo predefinido. Dispare a vetorização diretamente pela tabela abaixo.
              </p>
            </div>

            <div className="space-y-3">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <p className="text-xs uppercase text-slate-500 dark:text-slate-400">Coleções</p>
                  {visibleCollections.length > 0 && (
                    <span className="text-[11px] text-slate-500 dark:text-slate-400">
                      {visibleCollections.length} {visibleCollections.length === 1 ? 'coleção' : 'coleções'}
                    </span>
                  )}
                </div>
                {visibleCollections.length > 0 ? (
                  <div className="overflow-hidden rounded-md border border-slate-200 dark:border-slate-700">
                    <table className="w-full text-sm">
                      <thead className="bg-slate-100 dark:bg-slate-800 text-[11px] uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        <tr>
                          <th className="px-3 py-2 text-left font-semibold">Coleção</th>
                          <th className="px-3 py-2 text-left font-semibold">Modelo</th>
                          <th className="px-3 py-2 text-right font-semibold">Chunks</th>
                          <th className="px-3 py-2 text-right font-semibold">Órfãos</th>
                          <th className="px-3 py-2 text-right font-semibold">Doc. total</th>
                          <th className="px-3 py-2 text-right font-semibold">Indexados</th>
                          <th className="px-3 py-2 text-right font-semibold">Pendentes</th>
                          <th className="px-3 py-2 text-right font-semibold">Ações</th>
                        </tr>
                      </thead>
                      <tbody>
                        {visibleCollections.map((option) => {
                          const isActive =
                            effectiveCollectionValue &&
                            option.name.toLowerCase() === effectiveCollectionValue.toLowerCase();
                          const statsKey = option.name.toLowerCase();
                          const docOverview = collectionDocStats[statsKey];
                          const resetApplied = Boolean(resetCollections[statsKey]);
                          const docTotal =
                            docOverview && typeof docOverview.total === 'number'
                              ? docOverview.total
                              : 0;
                          const docIndexedRaw =
                            docOverview && typeof docOverview.indexed === 'number'
                              ? docOverview.indexed
                              : 0;
                          const docMissingRaw =
                            docOverview && typeof docOverview.missing === 'number'
                              ? docOverview.missing
                              : Math.max(docTotal - docIndexedRaw, 0);
                          const docOrphansRaw =
                            docOverview && typeof docOverview.orphans === 'number'
                              ? docOverview.orphans
                              : 0;
                          const docIndexed = resetApplied ? 0 : docIndexedRaw;
                          const docOrphans = resetApplied ? 0 : docOrphansRaw;
                          const docMissing = resetApplied ? docTotal : docMissingRaw;
                          // Use actual Qdrant chunks from collectionDocStats, fallback to option.count or docIndexed
                          const displayChunks = docOverview?.chunks ?? option.count ?? docIndexed;
                          const formatDocValue = (value: number | null) =>
                            typeof value === 'number' ? value.toLocaleString() : '—';
                          const logEntry = collectionLogs[statsKey];
                          const logLines = logEntry?.lines ?? [];
                          const logVisible = Boolean(logEntry?.visible);
                          const logHasContent = logLines.length > 0;
                          const deleting = Boolean(deletingCollections[statsKey]);

                          const collectionExists = option.exists ?? (docIndexed > 0);

                          return (
                            <tr
                              key={option.name}
                              role="button"
                              tabIndex={0}
                              onClick={() => onCollectionChange(option.name)}
                              onKeyDown={(event) => {
                                if (event.key === 'Enter' || event.key === ' ') {
                                  event.preventDefault();
                                  onCollectionChange(option.name);
                                }
                              }}
                              className={`cursor-pointer border-t border-slate-200 dark:border-slate-700 transition-colors ${
                                isActive
                                  ? 'bg-sky-50 dark:bg-sky-900/30'
                                  : 'hover:bg-slate-50 dark:hover:bg-slate-800/60'
                              }`}
                            >
                              <td className="px-3 py-2 align-middle text-slate-700 dark:text-slate-200">
                                <div className="flex items-center gap-2 font-medium">
                                  <span>{option.name}</span>
                                  {option.aliasOf && (
                                    <Badge variant="secondary" className="text-[10px] uppercase tracking-wide">
                                      alias de {option.aliasOf}
                                    </Badge>
                                  )}
                                  {!collectionExists && (
                                    <Badge variant="destructive" className="text-[10px] uppercase tracking-wide">
                                      ausente
                                    </Badge>
                                  )}
                                </div>
                              </td>
                              <td className="px-3 py-2 align-middle text-slate-500 dark:text-slate-400">
                                {option.embeddingModel ? (
                                  <Badge variant="outline">{option.embeddingModel}</Badge>
                                ) : (
                                  '—'
                                )}
                              </td>
                              <td className="px-3 py-2 align-middle text-right text-slate-600 dark:text-slate-300">
                                {formatDocValue(displayChunks)}
                              </td>
                              <td className="px-3 py-2 align-middle text-right text-slate-600 dark:text-slate-300">
                                  <Badge variant={docOrphans > 0 ? 'destructive' : 'outline'}>
                                    {formatDocValue(docOrphans)}
                                  </Badge>
                              </td>
                              <td className="px-3 py-2 align-middle text-right text-slate-600 dark:text-slate-300">
                                {formatDocValue(docTotal)}
                              </td>
                              <td className="px-3 py-2 align-middle text-right text-slate-600 dark:text-slate-300">
                                <Badge variant="outline">{formatDocValue(docIndexed)}</Badge>
                              </td>
                              <td className="px-3 py-2 align-middle text-right text-slate-600 dark:text-slate-300">
                                <Badge variant={docMissing === 0 ? 'default' : 'outline'}>
                                  {formatDocValue(docMissing)}
                                </Badge>
                              </td>
                              <td className="px-3 py-2 align-middle">
                                <div className="flex flex-wrap justify-end gap-2">
                                  <Button
                                    size="sm"
                                    variant={isActive ? 'default' : 'outline'}
                                    disabled={cleaningOrphans || ingesting || visibleCollections.length === 0}
                                    onClick={async (event) => {
                                      event.stopPropagation();
                                      // Primeiro limpa chunks órfãos (se houver)
                                      if (docOrphans > 0) {
                                        await onCleanOrphans(option.name);
                                      }
                                      // Depois indexa arquivos pendentes
                                      await onRunIngest(option.name);
                                    }}
                                  >
                                    {cleaningOrphans && isActive
                                      ? 'Limpando…'
                                      : ingesting && isActive
                                        ? 'Indexando…'
                                        : 'Atualizar'}
                                  </Button>
                                  <Button
                                    size="sm"
                                    variant="destructive"
                                    disabled={deleting || ingesting || cleaningOrphans}
                                    onClick={(event) => {
                                      event.stopPropagation();
                                      onDeleteCollection(option.name);
                                    }}
                                  >
                                    {deleting ? 'Apagando…' : 'Apagar'}
                                  </Button>
                                  <Button
                                    size="sm"
                                    variant="ghost"
                                    className="text-xs"
                                    disabled={!logHasContent}
                                    onClick={(event) => {
                                      event.stopPropagation();
                                      onToggleLog(option.name);
                                    }}
                                  >
                                    {logVisible ? 'Ocultar log' : 'Mostrar log'}
                                  </Button>
                                </div>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                ) : (
                  <p className="text-xs text-slate-500 dark:text-slate-400">
                    Nenhuma coleção foi retornada pelo serviço de ingestão.
                  </p>
                )}

                {visibleCollections.map((option) => {
                  const statsKey = option.name.toLowerCase();
                  const logEntry = collectionLogs[statsKey];
                  if (!logEntry || !logEntry.visible || logEntry.lines.length === 0) {
                    return null;
                  }
                  const statusLabel =
                    logEntry.status === 'running'
                      ? 'Em execução'
                      : logEntry.status === 'success'
                        ? 'Concluído'
                        : logEntry.status === 'error'
                          ? 'Erro'
                          : 'Aguardando';
                  const statusColor =
                    logEntry.status === 'running'
                      ? 'text-amber-400'
                      : logEntry.status === 'success'
                        ? 'text-emerald-400'
                        : logEntry.status === 'error'
                          ? 'text-red-400'
                          : 'text-slate-400';

                  const isLogCollapsed = logCollapsed[option.name] ?? false;

                  return (
                    <div
                      key={`${option.name}-log-panel`}
                      className="rounded-md border border-slate-200 dark:border-slate-700 bg-slate-950 text-lime-300"
                    >
                      <div className="flex items-center justify-between px-3 py-2 border-b border-slate-800">
                        <div className="flex flex-col">
                          <span className="text-sm font-semibold text-lime-200">{option.name}</span>
                          <span className={`text-[11px] uppercase ${statusColor}`}>{statusLabel}</span>
                        </div>
                        <div className="flex items-center gap-2 text-[11px] text-slate-400">
                          <span>
                            Atualizado em {new Date(logEntry.lastUpdated).toLocaleTimeString()}
                          </span>
                          <Button 
                            size="sm" 
                            variant="ghost" 
                            className="text-xs text-lime-300" 
                            onClick={() => toggleLogCollapse(option.name)}
                          >
                            {isLogCollapsed ? 'Expandir' : 'Recolher'}
                          </Button>
                          <Button 
                            size="sm" 
                            variant="ghost" 
                            className="text-xs text-lime-300" 
                            onClick={() => onToggleLog(option.name)}
                          >
                            Fechar
                          </Button>
                        </div>
                      </div>
                      {!isLogCollapsed && (
                        <div className="max-h-60 overflow-y-auto px-3 py-2">
                          <pre className="whitespace-pre-wrap break-words text-[11px] font-mono leading-relaxed">
                            {logEntry.lines.join('\n')}
                          </pre>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>

            {(docDirectory || docScanTruncated) && (
              <div className="text-[11px] text-slate-500 dark:text-slate-400 space-y-1">
                {docDirectory && (
                  <p>
                    Diretório monitorado:{' '}
                    <code className="bg-slate-200/60 dark:bg-slate-800 px-1 py-0.5 rounded font-mono text-[11px] break-all">
                      {docDirectory}
                    </code>
                  </p>
                )}
                {docScanTruncated && !docError && (
                  <p className="text-amber-600 dark:text-amber-400">
                    * Amostra truncada para coleções extensas.
                  </p>
                )}
              </div>
            )}

            {docError && (
              <div className="rounded-md border border-red-300 bg-red-50 dark:bg-red-900/20 px-3 py-2 text-xs text-red-600 dark:text-red-300">
                {docError}
              </div>
            )}

          </div>
          {(docStats || docDirectory || docError) && (
            <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900/60 px-3 py-3 space-y-3">
              {unifiedFileList.length > 0 && (
                <DocumentsFilesTable files={unifiedFileList} />
              )}
            </div>
          )}

          {lastIngestion && (
            <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900/60 px-3 py-3 space-y-2">
              <div className="flex items-center justify-between">
                <p className="text-sm font-medium text-slate-700 dark:text-slate-200">Última ingestão</p>
                {lastIngestion.embedding_model && <Badge variant="outline">{lastIngestion.embedding_model}</Badge>}
              </div>
              <p className="text-xs text-slate-500 dark:text-slate-400">
                {lastIngestion.message || (lastIngestion.success ? 'Ingestão concluída.' : 'Ingestão executada.')}
              </p>
              <div className="grid grid-cols-2 gap-2 text-xs text-slate-600 dark:text-slate-400">
                {typeof lastIngestion.documents_loaded === 'number' ? (
                  <div>
                    <span className="font-semibold text-slate-700 dark:text-slate-200">
                      {lastIngestion.documents_loaded}
                    </span>{' '}
                    documentos carregados
                  </div>
                ) : null}
                {typeof lastIngestion.chunks_generated === 'number' ? (
                  <div>
                    <span className="font-semibold text-slate-700 dark:text-slate-200">
                      {lastIngestion.chunks_generated}
                    </span>{' '}
                    fragmentos indexados
                  </div>
                ) : typeof lastIngestion.documents_processed === 'number' ? (
                  <div>
                    <span className="font-semibold text-slate-700 dark:text-slate-200">
                      {lastIngestion.documents_processed}
                    </span>{' '}
                    documentos processados
                  </div>
                ) : null}
                <div>
                  <span className="font-semibold text-slate-700 dark:text-slate-200">
                    {lastIngestion.files_ingested ?? 0}
                  </span>{' '}
                  arquivos ingeridos
                </div>
                {typeof lastIngestion.files_considered === 'number' && (
                  <div>
                    <span className="font-semibold text-slate-700 dark:text-slate-200">
                      {lastIngestion.files_considered}
                    </span>{' '}
                    arquivos considerados
                  </div>
                )}
                {typeof lastIngestion.files_skipped === 'number' && (
                  <div>
                    <span className="font-semibold text-slate-700 dark:text-slate-200">
                      {lastIngestion.files_skipped}
                    </span>{' '}
                    arquivos ignorados
                  </div>
                )}
              </div>
              {(typeof lastIngestion.chunk_size === 'number' || typeof lastIngestion.chunk_overlap === 'number') && (
                <p className="text-[11px] text-slate-500 dark:text-slate-400">
                  Chunking: tamanho {lastIngestion.chunk_size ?? '–'} • overlap {lastIngestion.chunk_overlap ?? '–'}
                </p>
              )}
              {lastIngestion.skipped_files_size?.length ? (
                <div className="text-[11px] text-slate-500 dark:text-slate-400 space-y-1">
                  <p className="font-semibold text-slate-600 dark:text-slate-200">Arquivos ignorados por tamanho</p>
                  <ul className="list-disc list-inside space-y-0.5">
                    {lastIngestion.skipped_files_size.slice(0, 5).map((item, idx) => (
                      <li key={`skipped-size-${idx}`} className="truncate">
                        {item}
                      </li>
                    ))}
                    {lastIngestion.skipped_files_size.length > 5 && <li>…</li>}
                  </ul>
                </div>
              ) : null}
              {lastIngestion.largest_files?.length ? (
                <div className="text-[11px] text-slate-500 dark:text-slate-400 space-y-1">
                  <p className="font-semibold text-slate-600 dark:text-slate-200">Maiores arquivos analisados</p>
                  <ul className="list-disc list-inside space-y-0.5">
                    {lastIngestion.largest_files.slice(0, 5).map((item, idx) => (
                      <li key={`largest-${idx}`} className="truncate">
                        {item}
                      </li>
                    ))}
                    {lastIngestion.largest_files.length > 5 && <li>…</li>}
                  </ul>
                </div>
              ) : null}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default LlamaIndexIngestionStatusCard;
