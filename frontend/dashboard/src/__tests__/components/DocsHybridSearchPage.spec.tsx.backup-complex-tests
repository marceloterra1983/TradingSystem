/**
 * DocsHybridSearchPage Component Tests
 *
 * Based on analyses:
 * - Code Review: 01-code-review-DocsHybridSearchPage.md
 * - Architecture Review: 02-architecture-review-docs-search.md
 * - Performance Audit: 03-performance-audit-frontend.md
 *
 * Test Coverage:
 * - Component rendering and initialization
 * - Search functionality (hybrid → lexical fallback)
 * - Filter interactions (domain, type, status, tags)
 * - Collection switching with localStorage persistence
 * - Inline preview expansion
 * - Modal preview opening
 * - Error handling and loading states
 * - localStorage state management
 * - Debounced search behavior
 */

import { describe, expect, it, beforeEach, afterEach, vi } from 'vitest';
import { fireEvent, render, screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import DocsHybridSearchPage from '../../components/pages/DocsHybridSearchPage';
import type { DocsHybridItem, DocsHybridResponse, DocsFacets } from '../../services/documentationService';

// Mock dependencies
vi.mock('../../services/documentationService', () => ({
  __esModule: true,
  default: {
    docsHybridSearch: vi.fn(),
    docsLexicalSearch: vi.fn(),
    getDocsFacets: vi.fn(),
    getDocContent: vi.fn(),
  },
}));

vi.mock('../../components/pages/DocPreviewModal', () => ({
  DocPreviewModal: ({ isOpen, onClose, title }: { isOpen: boolean; onClose: () => void; title: string }) =>
    isOpen ? <div data-testid="preview-modal"><h1>{title}</h1><button onClick={onClose}>Close</button></div> : null,
}));

vi.mock('../../components/pages/CollectionSelector', () => ({
  CollectionSelector: ({ value, onChange }: { value: string; onChange: (v: string) => void }) => (
    <select data-testid="collection-selector" value={value} onChange={(e) => onChange(e.target.value)}>
      <option value="">documentation</option>
      <option value="docs_index_mxbai">docs_index_mxbai</option>
      <option value="custom_collection">custom_collection</option>
    </select>
  ),
}));

vi.mock('../../utils/docusaurus', () => ({
  normalizeDocsApiPath: (url: string) => url.replace(/^\/docs\//, '/'),
  resolveDocsPreviewUrl: (url: string) => `http://localhost:3400${url}`,
}));

import documentationService from '../../services/documentationService';

const mockedHybridSearch = documentationService.docsHybridSearch as unknown as vi.Mock;
const mockedLexicalSearch = documentationService.docsLexicalSearch as unknown as vi.Mock;
const mockedGetFacets = documentationService.getDocsFacets as unknown as vi.Mock;
const mockedGetDocContent = documentationService.getDocContent as unknown as vi.Mock;

// Test fixtures
const mockHybridResults: DocsHybridItem[] = [
  {
    title: 'Docker Compose Setup',
    url: '/docs/tools/docker/overview',
    path: 'tools/docker/overview',
    snippet: 'Docker Compose configuration for TradingSystem',
    score: 0.92,
    source: 'hybrid',
    components: { semantic: true, lexical: true },
    tags: ['docker', 'infrastructure'],
    domain: 'tools',
    type: 'guide',
    status: 'active',
  },
  {
    title: 'Docker Troubleshooting',
    url: '/docs/tools/docker/troubleshooting',
    path: 'tools/docker/troubleshooting',
    snippet: 'Common Docker issues and solutions',
    score: 0.85,
    source: 'hybrid',
    components: { semantic: true, lexical: false },
    tags: ['docker', 'troubleshooting'],
    domain: 'tools',
    type: 'reference',
    status: 'active',
  },
];

const mockFacets: DocsFacets = {
  domains: [
    { value: 'tools', count: 15 },
    { value: 'api', count: 12 },
    { value: 'frontend', count: 8 },
  ],
  types: [
    { value: 'guide', count: 20 },
    { value: 'reference', count: 18 },
    { value: 'tutorial', count: 10 },
  ],
  statuses: [
    { value: 'active', count: 40 },
    { value: 'draft', count: 5 },
    { value: 'deprecated', count: 2 },
  ],
  tags: [
    { value: 'docker', count: 10 },
    { value: 'api', count: 8 },
    { value: 'frontend', count: 6 },
  ],
};

describe('DocsHybridSearchPage', () => {
  beforeEach(() => {
    // Clear localStorage (handle jsdom's implementation)
    if (typeof localStorage !== 'undefined') {
      Object.keys(localStorage).forEach(key => localStorage.removeItem(key));
    }

    // Reset all mocks
    mockedHybridSearch.mockReset();
    mockedLexicalSearch.mockReset();
    mockedGetFacets.mockReset();
    mockedGetDocContent.mockReset();

    // Default mock responses
    mockedGetFacets.mockResolvedValue(mockFacets);
    mockedHybridSearch.mockResolvedValue({
      total: mockHybridResults.length,
      results: mockHybridResults,
      alpha: 0.65,
      collection: 'docs_index_mxbai',
    } as DocsHybridResponse);
  });

  afterEach(() => {
    vi.clearAllTimers();
  });

  describe('Component Initialization', () => {
    it('should render search input and configuration card', () => {
      render(<DocsHybridSearchPage />);

      expect(screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i)).toBeInTheDocument();
      expect(screen.getByText(/Consulta e ajustes/i)).toBeInTheDocument();
      expect(screen.getByText(/Resultados/i)).toBeInTheDocument();
    });

    it('should load facets on mount', { timeout: 60000 }, async () => {
      render(<DocsHybridSearchPage />);

      await waitFor(() => {
        expect(mockedGetFacets).toHaveBeenCalledWith('');
      });
    });

    it('should restore previous search from localStorage', () => {
      const scopedKey = 'docsHybridSearch_lastQuery:default';
      localStorage.setItem(scopedKey, 'docker');
      localStorage.setItem('docsHybridSearch_results:default', JSON.stringify(mockHybridResults));

      render(<DocsHybridSearchPage />);

      const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i) as HTMLInputElement;
      expect(input.value).toBe('docker');
    });

    it('should restore collection from localStorage', () => {
      localStorage.setItem('docsHybridSearch_collection', 'docs_index_mxbai');

      render(<DocsHybridSearchPage />);

      const selector = screen.getByTestId('collection-selector') as HTMLSelectElement;
      expect(selector.value).toBe('docs_index_mxbai');
    });
  });

  describe('Search Functionality', () => {
    it('should perform hybrid search after debounce delay', { timeout: 60000 }, async () => {
      vi.useFakeTimers();
      try {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');

        // Should not call immediately
        expect(mockedHybridSearch).not.toHaveBeenCalled();

        // Fast-forward past debounce delay (400ms)
        await vi.advanceTimersByTimeAsync(400);
        await vi.runAllTimersAsync();

        await waitFor(() => {
          expect(mockedHybridSearch).toHaveBeenCalledWith(
            'docker',
            expect.objectContaining({
              alpha: 0.65,
              limit: 50,
            })
          );
        });
      } finally {
        vi.useRealTimers();
      }
    });

    it('should display hybrid search results', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
          expect(screen.getByText('Docker Troubleshooting')).toBeInTheDocument();
        });

        // Check badges
        expect(screen.getAllByText(/semantic/i)).toHaveLength(2);
        expect(screen.getAllByText(/lexical/i)).toHaveLength(1);
    });

    it('should fallback to lexical search when hybrid fails', { timeout: 60000 }, async () => {
        mockedHybridSearch.mockRejectedValue(new Error('Qdrant connection failed'));
        mockedLexicalSearch.mockResolvedValue({
          total: 1,
          results: [{
            title: 'Docker Guide',
            path: 'tools/docker/guide',
            summary: 'Docker setup guide',
            score: 0.8,
            tags: ['docker'],
            domain: 'tools',
            type: 'guide',
            status: 'active',
          }],
        });

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(mockedLexicalSearch).toHaveBeenCalledWith(
            'docker',
            expect.objectContaining({
              limit: 50,
            })
          );
        });

        await waitFor(() => {
          expect(screen.getByText('Docker Guide')).toBeInTheDocument();
        });

        // Verify lexical badge
        expect(screen.getByText(/lexical/i)).toBeInTheDocument();
    });

    it('should show error when both hybrid and lexical searches fail', { timeout: 60000 }, async () => {
        mockedHybridSearch.mockRejectedValue(new Error('Network error'));
        mockedLexicalSearch.mockRejectedValue(new Error('Network error'));

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText(/Network error/i)).toBeInTheDocument();
        });
    });

    it('should not search for queries less than 2 characters', { timeout: 60000 }, async () => {
      vi.useFakeTimers();
      try {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'd');

        await vi.advanceTimersByTimeAsync(400);
        await vi.runAllTimersAsync();

        expect(mockedHybridSearch).not.toHaveBeenCalled();
      } finally {
        vi.useRealTimers();
      }
    });

    it('should clear results when clear button is clicked', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        const clearButton = screen.getByRole('button', { name: /Limpar/i });
        await userEvent.click(clearButton);

        await waitFor(() => {
          expect(screen.queryByText('Docker Compose Setup')).not.toBeInTheDocument();
        });

        expect((input as HTMLInputElement).value).toBe('');
    });
  });

  describe('Filter Functionality', () => {
    it('should filter results by domain', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getAllByRole('listitem')).toHaveLength(2);
        });

        // Open domain filter
        const domainSelect = screen.getAllByRole('combobox')[0];
        await userEvent.click(domainSelect);

        // Wait for dropdown to appear
        await waitFor(() => {
          expect(screen.getByText(/Tools/i)).toBeInTheDocument();
        });

        // Select 'tools' domain
        await userEvent.click(screen.getByText(/Tools/i));

        // Both results have domain='tools', so should still show 2
        await waitFor(() => {
          expect(screen.getAllByRole('listitem')).toHaveLength(2);
        });
    });

    it('should filter results by type', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getAllByRole('listitem')).toHaveLength(2);
        });

        // Open type filter
        const typeSelect = screen.getAllByRole('combobox')[1];
        await userEvent.click(typeSelect);

        // Select 'guide' type
        await waitFor(() => {
          expect(screen.getByText(/Guide/i)).toBeInTheDocument();
        });
        await userEvent.click(screen.getByText(/Guide/i));

        // Only first result has type='guide'
        await waitFor(() => {
          expect(screen.getAllByRole('listitem')).toHaveLength(1);
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
          expect(screen.queryByText('Docker Troubleshooting')).not.toBeInTheDocument();
        });
    });

    it('should add and remove tags', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Tags should appear as suggestions
        const dockerTag = screen.getByText(/docker/i);
        await userEvent.click(dockerTag);

        // Tag should move to active tags
        await waitFor(() => {
          expect(screen.getByText(/Tags ativas:/i)).toBeInTheDocument();
        });

        // Click to remove tag
        const activeTag = screen.getByText(/Docker ×/i);
        await userEvent.click(activeTag);

        await waitFor(() => {
          expect(screen.queryByText(/Tags ativas:/i)).not.toBeInTheDocument();
        });
    });
  });

  describe('Collection Management', () => {
    it('should switch collections and restore scoped state', { timeout: 60000 }, async () => {
      localStorage.setItem('docsHybridSearch_lastQuery:default', 'docker');
      localStorage.setItem('docsHybridSearch_lastQuery:docs_index_mxbai', 'workspace');

      render(<DocsHybridSearchPage />);

      const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i) as HTMLInputElement;
      expect(input.value).toBe('docker');

      // Switch to different collection
      const selector = screen.getByTestId('collection-selector');
      await userEvent.selectOptions(selector, 'docs_index_mxbai');

      // Should restore scoped query
      await waitFor(() => {
        expect(input.value).toBe('workspace');
      });
    });

    it('should persist collection in localStorage', { timeout: 60000 }, async () => {
      render(<DocsHybridSearchPage />);

      const selector = screen.getByTestId('collection-selector');
      await userEvent.selectOptions(selector, 'custom_collection');

      await waitFor(() => {
        expect(localStorage.getItem('docsHybridSearch_collection')).toBe('custom_collection');
      });
    });

    it('should reset filters when switching collections', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        // Set domain filter
        const domainSelect = screen.getAllByRole('combobox')[0];
        await userEvent.click(domainSelect);
        await waitFor(() => expect(screen.getByText(/Tools/i)).toBeInTheDocument());
        await userEvent.click(screen.getByText(/Tools/i));

        // Switch collection
        const selector = screen.getByTestId('collection-selector');
        await userEvent.selectOptions(selector, 'docs_index_mxbai');

        // Domain filter should be reset to '__all__'
        await waitFor(() => {
          expect(domainSelect).toHaveValue('__all__');
        });
    });
  });

  describe('Inline Preview', () => {
    it('should expand inline preview and fetch content', { timeout: 60000 }, async () => {
        mockedGetDocContent.mockResolvedValue('# Docker Setup\n\nInstallation guide...');

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Click chevron to expand
        const expandButtons = screen.getAllByTitle(/Mostrar prévia inline/i);
        await userEvent.click(expandButtons[0]);

        await waitFor(() => {
          expect(mockedGetDocContent).toHaveBeenCalledWith('/tools/docker/overview');
        });

        // Should show loading state
        expect(screen.getByText(/Carregando prévia/i)).toBeInTheDocument();

        // Wait for content to load
        await waitFor(() => {
          expect(screen.getByText(/Docker Setup/i)).toBeInTheDocument();
        });
    });

    it('should collapse inline preview when clicked again', { timeout: 60000 }, async () => {
        mockedGetDocContent.mockResolvedValue('# Docker Setup\n\nInstallation guide...');

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Expand
        const expandButton = screen.getAllByTitle(/Mostrar prévia inline/i)[0];
        await userEvent.click(expandButton);

        await waitFor(() => {
          expect(screen.getByText(/Docker Setup/i)).toBeInTheDocument();
        });

        // Collapse
        const collapseButton = screen.getByTitle(/Ocultar prévia inline/i);
        await userEvent.click(collapseButton);

        await waitFor(() => {
          expect(screen.queryByText(/Docker Setup/i)).not.toBeInTheDocument();
        });
    });

    it('should show error and retry button when content fetch fails', { timeout: 60000 }, async () => {
        mockedGetDocContent.mockRejectedValue(new Error('404 Not Found'));

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Expand
        const expandButton = screen.getAllByTitle(/Mostrar prévia inline/i)[0];
        await userEvent.click(expandButton);

        await waitFor(() => {
          expect(screen.getByText(/404 Not Found/i)).toBeInTheDocument();
        });

        // Retry button should be present
        const retryButton = screen.getByRole('button', { name: /Tentar novamente/i });
        expect(retryButton).toBeInTheDocument();

        // Click retry
        mockedGetDocContent.mockResolvedValue('# Docker Setup\n\nRetry successful...');
        await userEvent.click(retryButton);

        await waitFor(() => {
          expect(screen.getByText(/Retry successful/i)).toBeInTheDocument();
        });
    });
  });

  describe('Modal Preview', () => {
    it('should open preview modal when result title is clicked', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Click title with eye icon
        const titleButton = screen.getAllByRole('button', { name: /Docker Compose Setup/i })[0];
        await userEvent.click(titleButton);

        // Modal should open
        await waitFor(() => {
          expect(screen.getByTestId('preview-modal')).toBeInTheDocument();
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });
    });

    it('should close preview modal', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Open modal
        const titleButton = screen.getAllByRole('button', { name: /Docker Compose Setup/i })[0];
        await userEvent.click(titleButton);

        await waitFor(() => {
          expect(screen.getByTestId('preview-modal')).toBeInTheDocument();
        });

        // Close modal
        const closeButton = screen.getByRole('button', { name: /Close/i });
        await userEvent.click(closeButton);

        await waitFor(() => {
          expect(screen.queryByTestId('preview-modal')).not.toBeInTheDocument();
        });
    });
  });

  describe('LocalStorage Persistence', () => {
    it('should persist search query to localStorage', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          const storedQuery = localStorage.getItem('docsHybridSearch_lastQuery:default');
          expect(storedQuery).toBe('docker');
        });
    });

    it('should persist search results to localStorage', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          const storedResults = localStorage.getItem('docsHybridSearch_results:default');
          expect(storedResults).toBeDefined();
          const parsed = JSON.parse(storedResults!);
          expect(parsed).toHaveLength(2);
        });
    });

    it('should clear localStorage when clear button is clicked', { timeout: 60000 }, async () => {
        localStorage.setItem('docsHybridSearch_lastQuery:default', 'docker');
        localStorage.setItem('docsHybridSearch_results:default', JSON.stringify(mockHybridResults));

        render(<DocsHybridSearchPage />);

        const clearButton = screen.getByRole('button', { name: /Limpar/i });
        await userEvent.click(clearButton);

        await waitFor(() => {
          expect(localStorage.getItem('docsHybridSearch_lastQuery:default')).toBeNull();
          expect(localStorage.getItem('docsHybridSearch_results:default')).toBeNull();
        });
    });
  });

  describe('Alpha Configuration', () => {
    it('should adjust alpha value and trigger new search', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(mockedHybridSearch).toHaveBeenCalledWith(
            'docker',
            expect.objectContaining({ alpha: 0.65 })
          );
        });

        // Open advanced settings
        const advancedSettings = screen.getByText(/Configurações avançadas/i);
        await userEvent.click(advancedSettings);

        // Adjust alpha slider
        const alphaSlider = screen.getByRole('slider');
        fireEvent.change(alphaSlider, { target: { value: '0.5' } });

        // Should trigger new search with updated alpha
        await waitFor(() => {
          expect(mockedHybridSearch).toHaveBeenCalledWith(
            'docker',
            expect.objectContaining({ alpha: 0.5 })
          );
        });
    });
  });

  describe('Copy and External Link Actions', () => {
    it('should copy document URL to clipboard', { timeout: 60000 }, async () => {
        // Mock clipboard API
        const writeTextMock = vi.fn().mockResolvedValue(undefined);
        Object.assign(navigator, {
          clipboard: {
            writeText: writeTextMock,
          },
        });

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Find and click copy button
        const copyButtons = screen.getAllByTitle(/Copiar link/i);
        await userEvent.click(copyButtons[0]);

        expect(writeTextMock).toHaveBeenCalledWith('http://localhost:3400/docs/tools/docker/overview');
    });

    it('should open document in new tab', { timeout: 60000 }, async () => {
        const openSpy = vi.spyOn(window, 'open').mockImplementation(() => null);

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        });

        // Find and click external link button
        const externalButtons = screen.getAllByTitle(/Abrir em nova aba/i);
        await userEvent.click(externalButtons[0]);

        expect(openSpy).toHaveBeenCalledWith('http://localhost:3400/docs/tools/docker/overview', '_blank');

        openSpy.mockRestore();
    });
  });

  describe('Loading and Error States', () => {
    it('should show loading indicator while searching', { timeout: 60000 }, async () => {
        // Create a promise that doesn't resolve immediately
        let resolveSearch: (value: DocsHybridResponse) => void;
        const searchPromise = new Promise<DocsHybridResponse>((resolve) => {
          resolveSearch = resolve;
        });
        mockedHybridSearch.mockReturnValue(searchPromise);

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        // Should show loading
        await waitFor(() => {
          expect(screen.getByText(/Carregando resultados/i)).toBeInTheDocument();
        });

        // Resolve search
        resolveSearch!({
          total: mockHybridResults.length,
          results: mockHybridResults,
          alpha: 0.65,
          collection: 'docs_index_mxbai',
        });

        // Loading should disappear
        await waitFor(() => {
          expect(screen.queryByText(/Carregando resultados/i)).not.toBeInTheDocument();
        });
    });

    it('should display error message when search fails', { timeout: 60000 }, async () => {
        mockedHybridSearch.mockRejectedValue(new Error('Connection timeout'));
        mockedLexicalSearch.mockRejectedValue(new Error('Connection timeout'));

        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker');


        await waitFor(() => {
          expect(screen.getByText(/Connection timeout/i)).toBeInTheDocument();
        });
    });
  });

  describe('Keyboard Shortcuts', () => {
    it('should trigger search on Enter key', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i);
        await userEvent.type(input, 'docker{Enter}');

        // Should debounce and search (wait for 400ms debounce + processing)
        await waitFor(() => {
          expect(mockedHybridSearch).toHaveBeenCalledWith(
            'docker',
            expect.objectContaining({ alpha: 0.65 })
          );
        }, { timeout: 10000 }); // 10s timeout for debounce
    });

    it('should clear search on Escape key', { timeout: 60000 }, async () => {
        render(<DocsHybridSearchPage />);

        const input = screen.getByPlaceholderText(/Ex.: docker, workspace api, docusaurus/i) as HTMLInputElement;
        await userEvent.type(input, 'docker');

        // Wait for debounce + search to complete
        await waitFor(() => {
          expect(screen.getByText('Docker Compose Setup')).toBeInTheDocument();
        }, { timeout: 10000 });

        // Press Escape
        fireEvent.keyDown(input, { key: 'Escape', code: 'Escape' });

        await waitFor(() => {
          expect(input.value).toBe('');
          expect(screen.queryByText('Docker Compose Setup')).not.toBeInTheDocument();
        }, { timeout: 5000 });
    });
  });
});
