name: Infrastructure Health Check

on:
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours
  workflow_dispatch: # Manual trigger
  pull_request:
    branches: [main, develop]
    paths:
      - 'tools/compose/**'
      - 'scripts/maintenance/**'
      - 'scripts/docker/**'

jobs:
  health-check:
    name: System Health Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        run: |
          echo "üì¶ Setting up environment..."
          cp .env.example .env

          # Set test environment variables
          cat >> .env << EOF
          WORKSPACE_DB_HOST=localhost
          WORKSPACE_DB_PORT=7432
          QUESTDB_HOST=localhost
          QUESTDB_HTTP_PORT=9000
          REDIS_HOST=localhost
          REDIS_PORT=6379
          QDRANT_HOST=localhost
          QDRANT_PORT=6333
          EOF

      - name: Start Docker infrastructure
        run: |
          echo "üê≥ Starting Docker infrastructure..."
          docker compose -f tools/compose/docker-compose.infra.yml up -d

          echo "‚è≥ Waiting for services to be ready..."
          sleep 45

      - name: Verify service health
        run: |
          echo "üè• Checking service health..."

          # TimescaleDB
          docker compose -f tools/compose/docker-compose.infra.yml exec -T timescaledb pg_isready || {
            echo "‚ùå TimescaleDB is not ready"
            exit 1
          }
          echo "‚úÖ TimescaleDB is healthy"

          # QuestDB
          curl -f http://localhost:9000/status || {
            echo "‚ùå QuestDB is not responding"
            exit 1
          }
          echo "‚úÖ QuestDB is healthy"

          # Redis
          docker compose -f tools/compose/docker-compose.infra.yml exec -T redis redis-cli ping | grep -q PONG || {
            echo "‚ùå Redis is not responding"
            exit 1
          }
          echo "‚úÖ Redis is healthy"

          # Qdrant
          curl -f http://localhost:6333/healthz || {
            echo "‚ùå Qdrant is not responding"
            exit 1
          }
          echo "‚úÖ Qdrant is healthy"

      - name: Run comprehensive health check
        run: |
          echo "üîç Running comprehensive health check..."
          bash scripts/maintenance/health-check-all.sh --format json > health-report.json

      - name: Validate health status
        run: |
          echo "üìä Validating health status..."

          OVERALL_HEALTH=$(jq -r '.overallHealth' health-report.json)

          if [ "$OVERALL_HEALTH" != "healthy" ]; then
            echo "‚ùå Health check failed!"
            cat health-report.json | jq '.'
            exit 1
          fi

          echo "‚úÖ All systems healthy"

      - name: Upload health report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: health-report-${{ github.run_number }}
          path: health-report.json
          retention-days: 30

      - name: Export Prometheus metrics
        if: success()
        run: |
          echo "üìà Exporting Prometheus metrics..."
          bash scripts/maintenance/health-check-all.sh --format prometheus > health-metrics.prom

      - name: Upload Prometheus metrics
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: prometheus-metrics-${{ github.run_number }}
          path: health-metrics.prom
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          docker compose -f tools/compose/docker-compose.infra.yml down -v

  docker-compose-validation:
    name: Validate All Compose Stacks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate infrastructure stack
        run: docker compose -f tools/compose/docker-compose.infra.yml config > /dev/null

      - name: Validate monitoring stack
        run: docker compose -f tools/monitoring/docker-compose.monitoring.yml config > /dev/null

      - name: Validate apps stack
        run: docker compose -f tools/compose/docker-compose.apps.yml config > /dev/null

      - name: Validate docs stack
        run: docker compose -f tools/compose/docker-compose.docs.yml config > /dev/null

      - name: Validate dashboard stack
        run: docker compose -f tools/compose/docker-compose.1-dashboard-stack.yml config > /dev/null

      - name: Validate RAG stack
        run: docker compose -f ai/compose/docker-compose.4-4-rag-stack.yml config > /dev/null

      - name: Check port conflicts
        run: |
          echo "üîç Checking for port conflicts across compose files..."

          # Extract all port mappings
          find . -name "docker-compose*.yml" -o -name "compose*.yml" | \
            xargs grep -h "ports:" -A 1 | \
            grep -E "^\s+- \"?[0-9]+" | \
            sed 's/.*"\([0-9]*\):.*/\1/' | \
            sort | uniq -d > duplicate_ports.txt

          if [ -s duplicate_ports.txt ]; then
            echo "‚ùå Found duplicate port mappings:"
            cat duplicate_ports.txt
            exit 1
          fi

          echo "‚úÖ No port conflicts detected"

  service-dependency-check:
    name: Validate Service Dependencies
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check service startup order
        run: |
          echo "üìã Validating service dependencies..."

          # Check if depends_on is properly configured
          find tools/compose -name "*.yml" | while read compose_file; do
            echo "Checking: $compose_file"

            # Validate that services with database dependencies have depends_on
            if grep -q "DATABASE_URL" "$compose_file"; then
              if ! grep -q "depends_on:" "$compose_file"; then
                echo "‚ö†Ô∏è Warning: $compose_file uses DATABASE_URL but has no depends_on"
              fi
            fi
          done

          echo "‚úÖ Service dependencies validated"
